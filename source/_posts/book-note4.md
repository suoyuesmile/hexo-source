---
title: 《JavaScript高级程序设计》读后记<四>：垃圾回收
date: 2015-11-29 15:22:15
categories: JavaScript
tags: JavaScript
---
上一篇博客里，阐明了闭包的概念和作用，但是它有个缺点就是容易造成内存泄露，为什么会造成内存泄露呢？内存泄露又是怎样产生的呢？这一切要从 JavaScript 的垃圾回收机制说起

### 理解JavaScript的垃圾回收机制
JavaScript 具有自动垃圾回收机制，因此我们可以不必管它，但是也要知道它的原理。
垃圾回收机制的原理：__垃圾回收机制会周期性的释放不再使用的变量的内存__。
这里我们要知道两点：
1.这个周期是多少？是如何决定的？
2.如何判断这个变量不再继续使用？

我们先来探究第二个问题，__如何判断这个变量不再使用，并回收__？
我们知道，每一个变量都是有生命周期的，如果哪个变量没有的话，就会一直残留下去，总有一天会消耗完内存。这也叫内存泄露。下面我们分析下局部变量的正常生命周期
局部变量只在函数执行过程中存在，函数执行结束后，局部变量就没有存在价值了，然后垃圾回收器给无用的局部变量标记。等回收周期到来的时候，回收这个变量。

__标记变量有两种策略：一种是标记清除法，另一种是引用计数法__
这个标记清除法其实很简单解释，当变量进入环境时（变量声明），该变量就被标记为“进入环境”。当变量离开环境时（函数执行完），该变量就被标记为“离开环境”。而这些被标记成离开环境的变量就是无用变量，等着垃圾回收机制回收就可以了

第二个问题清楚了，我们看看第一个问题，__垃圾回收机制的周期是多少？怎么决定的？__
从 IE 开始谈起，IE 垃圾回收器是根据内存分配量运行的，具体就是 256 个变量，4096 个对象字面量，数组元素，或者 64Kb 的字符串。达到上面任何一个临界值，垃圾回收器就开始运行。但是这样又出现了一个问题，如果一个脚本本来就有那么多变量，垃圾回收器就会一直的运行。每次回收完了又到达临界值，这样导致垃圾回收器频繁的调用，对性能来说是有很大影响的。

等到 IE7 的出现，重写了垃圾回收机制。__固定的临界量改为了动态的分配__。垃圾回收的内存分配量低于 15% 时，临界值就加倍。当内存分配量达 85% 时，临界时恢复为初始的值。简单的来说就是，内存够用时，就不急着回收。内存不够时，就和初始一样，达到就回收。这样一来，即便脚本中的变量很多，只要内存够用，也不会频繁的调用垃圾回收器了。

在 JavaScript 中虽然我们不必担心内存管理的问题，但是我们也需要保证页面的性能更好。这里我们可以去优化内存。__优化内存最佳的方式就是，将无用数据，设置为`null`,来释放其引用，也就是解除引用__。

下面我们来看一段代码
```js
function createPerson(name) {
    var  localPerson = new Object;
    localPerson.name = name;
    return localPerson;
}
var globalPerson = createPerson("suo");
// 解除引用
globalPerson = null;
```
这里我们可以知道的是`localPerson`是局部的变量，所以垃圾回收器会自动为它解除引用
但是`globalPerson`是全局变量，如果不需要用了，垃圾回收机制不会干，现在我们手动为它解除引用。解除引用之后，它不会立即销毁，只是脱离了执行环境，等待垃圾回收器来回收。

说了这么多，搞清楚了垃圾回收机制。上一篇博客中谈到闭包的缺点，闭包会造成内存泄露。清楚了垃圾回收机制，我们可以知道的是，闭包访问的变量是无法被垃圾回收器回收的。那么我们该怎么办了。恰好刚刚就有种方法。我们可以手动来解除引用。这样就避免了闭包产生的内存泄露了。
下面给出闭包和解除引用的实例
```js
function assignHadler() {
    var element = document.getElementById("div");
    var id = element.id;
    element.onclick = function() {
        alert(id);
    };
    // 解除引用
    element = null;
}
```




