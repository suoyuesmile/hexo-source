---
title: 《数据结构》笔记：算法分析
date: 2015-08-10 13:58:04
categories: 编程基础
tags: 数据结构
---
### 计算
*Dijkstra名言：计算机科学，就是计算的科学*
- 绳索计算机和算法：古埃及人的算法，线段垂直
- 尺规计算机和算法：线段三等分
- **总结：计算 = 信息处理，
借助某种工具，尊尊某种规则**
> 算法：特定计算模型下，解决问题的指令序列
1. 输入：待处理的信息
2. 输出：经处理的信息
3. 正确性：的确可以解决指定的问题
4. 确定性：基本操作组成的序列
5. 可行性：每个操作都可以实现，在常数时间内完成
6. 有穷性：如何输入，有穷次操作可以，得到输出结果
- 可行性：所有操作都可以兑现，例子3步把大象装到冰箱
- 有穷性：Hailstone(n)算法

```c
int hailstone(int n) {
    int length = 1;
    while(1 < n){   
        n%2==0 ? n/=2 : n=3*n+1;
        length++;
    }
}
```
**结论：所有的n是否都可以有穷的步骤，还没有结论**
> 程序 ！= 算法
### 计算模型
*凯文名言：如果你需要改进某种东西，你首先的学会如何测量它*

- 算法分析两个主要方面：正确性，成本
- 成本：时间成本，空间成本
- 怎么衡量时间成本：特定算法+不同示例
- 稳妥起见：关注最坏情况
- 同一问题多种算法，评价其优劣：实验统计不足够
- 图灵机模型
- - Tape(带)：均匀划分单元格，各注一字符，默认为'#'
- - Alphabet：字符种类有限
- - Head：总是对准某一单元格，并可以读取修改其中的字符，
          每经过一个节拍，可转向左侧或右侧
- - State TM：有限机状态
- - Transition Function：(q, c, d, L/R, p)
若当前状态为q，字符为c，将当前字符改写为d，转向左侧/右侧；转入p状态，一旦转入h停机
功能：二进制非负整数加一，全1的后缀转为0，原低位的0翻转为1
- RAM模型：寄存器顺序编号，总数没有限制

**总结：图灵机，RAM模型为度量算法性能提供了准确的尺度**
### 大O记号
*陶渊明名言：好读书不求甚解（更多的看重长远，主流）*

- 渐进分析： 考虑n >> 2, 对规模为n的输入，需执行的基本操作次数，存储单元数
- 大O记号（big-O notation）：**T(n) = O( f(n) )**  <=   **存在c > 0， n >> ,有 T(n) < c * f(n)**
- 常系数可忽略：
O（ c * f(n) ）= O ( f(n) )
- 低次项可忽略：
O ( n^a + n^b ) = O( n^a ) ,  a > b
- 其他记号：最好，平均情况
- 常数O(1)：2 = 2013 = 2013^2013 = O(1)，不含转向
- 对数O(logn)：**非常高效，无限接近与常数**
-  - 常底数无所谓
  所有 a, b > 0, log(a) n = log(a) b * log(b)n = O( log(b) n )
- - 常数次幂无所谓
- - 对数多项式
- 多项式（O（n ^c））:**直接往高处化，通常认为令人满意了**
- - 线性（O（n））
- - 从O（n）~ O（n^2）：编程题主要覆盖的范围
- - 幂
- 指数（a ^n）：计算成本增长极快，
和多项式之间有个分水岭（有效算法到无效算法）

```c
问题：2-Subset 
S包含n个正整数，存在S = 2m
是否有子集T，满足存在 T = m?
美国大选说事
```
**不存在可在多项式时间内解决该问题**
### 算法分析
*夸赞欧拉：像欧拉一样像呼吸一样自如*
- 主要任务：正确性+复杂度
- C++基本指令：等价于RAM的基本指令，二者相当
- - 分支转向：goto //出于结构化被隐藏了
- - 迭代循环：for（）、while（）、…… //本质上就是if + goto
- - 调用加递归 //本质上也是goto
- 分析方法：迭代（级数求和）、递归（递归跟踪+递推方程）、猜测
- 级数：
- - 算数级数（与末项平方同阶）：1 + 2 + …… + n = n (n+1) /2 = O(n^2)
- - 幂级数（比末项高出一阶）：1^C + 2^C + …… n^C = O( n^(C+1) )
- - 几何级数（与末项同阶）：a0 + a^1 + …… a^n = O(a^n)
- - 收敛级数： O（1）
- - 调和级数：1 + 1/2 + …… 1/n = O(logn)
- - 对数级数：log1 + log2 + …… + logn = log(n!) = O(nlogn)
- 循环与级数：
- - 二重循环复杂度：O(n^2)
```c
for(int i=0 ; i<n; i++)
    for(int j=0; j<n; j++)
        op();
        
//变化界限   
for(int i=0 ; i<n; i++)
    for(int j=0; j<i; j++)
        op();  
//变化步长
for(int i=0 ; i<n; i++)
    for(int j=0; j<i; j=+2017)
        op();  
```
**渐进复杂度依然一样：n + n + …… + n = n^2 = O(n^2)**

```c
//变化成几何级数
for(int i=0 ; i<n; i<<2)
    for(int j=0; j<n; j++)
        op();
```
**复杂度变为O(n)**
- - 例子：冒泡排序
> 估算：1天多少秒？
**1天 = 24hr * 60min * 60sec = 25 * 4000 = 100000 sec**
### 迭代与递归
**凡治众如治寡，分数是也**
- 例子求和

```c
int SumI(int A[], int n){
    int sum = 0; //O（1）
    for (int i = 0; i < n; ++i)
    {
        sum += A[i]; //O（1）
    }
    return sum;  //O（1）
}
// 时间复杂度：T(n)  = O（n）
// 空间复杂度：O(1)
```
- 减而治之：
> 求解一个大规模的问题，划分成两个子问题：其一平凡，其二规模缩减（单调性）

```c
int SumJ(int A[], int n){
    return (n < 1) ? 0 : SumJ(A, n-1) + A[n+1] ;
} //递归
递归跟踪：T(n) = O(1)*(n+1) = O(n)
递推方程：T(n) = T(n-1) + O(1)  T(0) = O(1)  ==> T(n) = O(n)
```
- 例子:数组倒置

```c
void reverse(int * Am int lo, int hi)；
//递归版
if(lo < hi) { swap(A[lo], A[hi]); reverse(A, lo+1, hi-1); }
```
- 分而治之：
> 求解一个大规模的问题，划分成多个子问题，规模相当，分别求解子问题

```c
int sum(int A[], int lo, int hi){
    if(lo == hi) return A[lo];
    int mi = (lo+hi) >> 1;
    return sum(A, lo, mi) + sum(A, mi + 1, hi);
}//二分递归
递归跟踪：T(n) = O(1) * (2^0 + ... + 2^logn) = O(n)
递推方程：T(n) = O(1) + 2T(n/2), T(1) = O(1)    T(n) = O(n);
```
- 例子：MAX2，[lo, hi) 找出最大和次大的

```c
if( A[x1 = lo] < A[x2 = lo + 1]) swap(x1, x2);
for(int i = lo + 2; i < hi; i++)
    if(A[x2] < A[i])
        if(A[x1] < A[x2 =i])
            swap(x1, x2);
复杂度：最好的 n-1次比较，最坏的2n-3次比较
改进：分而治之 最坏5n/3-2
```


### 动态规划(DSA优化)
> 运转-->正确-->快速

- 例子：fib()（递归）

```c
// fib(n) = f(n-1) + f(n-2) {0, 1, 1, 2, 3, 5, 8 ...}
int fib(n) { return (2 > n) ? n : fib(n-1) + fib(n-2); }
// fib(43)  ==> 巨大的延迟
//时间复杂度分析
//递推公式：T(n-1) + T(n-2) + 1, T(1) = T(0) = 1, S(n) = fib(n+1) = 1.68... ^n
//==> O(2^n) 指数复杂度  超过100项，需要几百年
//递归跟踪：大量重复的递归实例
```
- 例子：fib()（迭代）

```c
//方法A(记忆)
//制表查询
//方法B(动态规划)
//颠倒计算方向，自底而上
int fib2(int n){
    int f = 0, g = 1;  //用2个参数存储中间指
    while(0 < n--){
        g = g + f;
        f = g - f; 
    }
    return g;
}
//空间上只需要O(1)
```
- 例子：最长公共子序列（递归-->动态规划）

```c
/* 
 * 最长公共子序列
 * 可行---->递归策略---->减而治之---->平凡情况
 * 效率---->动态规划---->自底而上---->迭代策略
 * 对于序列A[0,n],B[0,m], LCS(A,B)无非3种情况
 * 1) n=-1或m=-1，作空序列
 * 2) A[n] = 'X' = B[m] 则LCS( A[0,n), B[0,m), 'X' )
 * 3) A[n] != B[m] 则 LCS( A[0,n], B[0,m) ) 与 LCS( A[0,n), B[0,m] ) 中取更长者(分而治之)
 * 采用倒推式方式求公共子序列，用二维数组存储中间值
 * 
 */
//递归
#include <iostream>
#include <string>
using namespace std;
int LCS(string, int, string, int);
int LCS2(string, int, string, int);
int main(void){
    string a, b;
    cin >> a >> b;
    cout << LCS(a, a.length()-1, b, b.length()-1) << endl;
    // cout << a << b << endl;
    return 0;
}
//递归
int LCS(string a, int m, string b, int n){
    if(m == -1 || n == -1)
        return 0;
    else if(a[m] == b[n])
        return LCS(a, m-1, b, n-1) + 1;
    else
        return LCS(a, m, b, n-1) > LCS(a, m-1, b, n)
        ? LCS(a, m, b, n-1) 
        : LCS(a, m-1, b, n);
}
//动态规划
int LCS(string a, int m, string b, int n){
    int arr[m][n] = {0};   //用数组存储中间值
    if(a[0] == a[0])
    
}
```
